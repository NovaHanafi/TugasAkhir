# -*- coding: utf-8 -*-
"""SYNFlood_DataProcessing_TA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WkX_KbmesLf3tKvlnmSJXjuVuqg6h7nF
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
syn = pd.read_csv("drive/MyDrive/Dataset/Syn.csv")

syn_cols = list(syn.columns.values)

print("SYN= ",syn.shape)
print("min =", min(syn.shape))

print("BENIGN= ",syn.shape)
print("min =", min(syn.shape))

ld =syn.iloc[:191694,]
ld.to_csv("drive/MyDrive/Dataset/DataProcess/Syn1.csv")

import pandas as pd 
syn = pd.read_csv("drive/MyDrive/Dataset/DataProcess/Syn1.csv")

syn.head()

syn.describe()

ds = pd.concat([syn])

ds.to_csv("drive/MyDrive/Dataset/DataProcess/SynProcess1.csv")

ds.info()

import pandas as pd
df = pd.read_csv("drive/MyDrive/Dataset/DataProcess/SynProcess1.csv")

print("columns: ", len(df.columns))
df.columns

df.describe()

df=df.drop(' Bwd PSH Flags',axis=1)
df=df.drop(' Fwd URG Flags',axis=1)
df=df.drop(' Bwd URG Flags',axis=1)
df=df.drop('FIN Flag Count',axis=1)
df=df.drop(' PSH Flag Count',axis=1)
df=df.drop(' ECE Flag Count',axis=1)
df=df.drop('Fwd Avg Bytes/Bulk',axis=1)
df=df.drop(' Fwd Avg Packets/Bulk',axis=1)
df=df.drop(' Fwd Avg Bulk Rate',axis=1)
df=df.drop(' Bwd Avg Bytes/Bulk',axis=1)
df=df.drop(' Bwd Avg Packets/Bulk',axis=1)
df=df.drop('Bwd Avg Bulk Rate',axis=1)
df=df.drop('Unnamed: 0',axis=1)
df=df.drop('Unnamed: 0.1',axis=1)
df=df.drop('SimillarHTTP', axis=1)
df=df.drop('Flow ID', axis=1)
df=df.drop(' Timestamp', axis=1)

df.to_csv("drive/MyDrive/Dataset/DataProcess/SynClean1.csv")

df = df.rename(columns={" Label": "Label"})
df.info()

df.columns

df=df.drop(' Source IP',axis=1)
df=df.drop(' Flow Duration',axis=1)
df=df.drop(' Total Fwd Packets',axis=1)
df=df.drop(' Total Backward Packets',axis=1)
df=df.drop(' Total Length of Bwd Packets',axis=1)
df=df.drop(' Fwd Packet Length Std',axis=1)
df=df.drop(' Flow IAT Max',axis=1)
df=df.drop(' Flow IAT Min',axis=1)
df=df.drop('Fwd IAT Total',axis=1)
df=df.drop(' Fwd IAT Max',axis=1)
df=df.drop(' Fwd IAT Min',axis=1)
df=df.drop('Bwd IAT Total',axis=1)
df=df.drop(' Bwd IAT Mean',axis=1)
df=df.drop(' Bwd IAT Std',axis=1)
df=df.drop(' Bwd IAT Max',axis=1)
df=df.drop(' Bwd IAT Min',axis=1)
df=df.drop(' Fwd Header Length',axis=1)
df=df.drop(' Bwd Header Length',axis=1)
df=df.drop(' Bwd Packets/s',axis=1)
df=df.drop(' SYN Flag Count',axis=1)
df=df.drop(' Down/Up Ratio',axis=1)
df=df.drop(' Fwd Header Length.1',axis=1)
df=df.drop('Subflow Fwd Packets',axis=1)
df=df.drop(' Subflow Bwd Packets',axis=1)
df=df.drop(' Subflow Bwd Bytes',axis=1)
df=df.drop(' act_data_pkt_fwd',axis=1)
df=df.drop(' min_seg_size_forward',axis=1)
df=df.drop('Active Mean',axis=1)
df=df.drop(' Active Std',axis=1)
df=df.drop(' Active Max',axis=1)
df=df.drop(' Active Min',axis=1)
df=df.drop('Idle Mean',axis=1)
df=df.drop(' Idle Max',axis=1)
df=df.drop(' Idle Min',axis=1)
df=df.drop(' Packet Length Std',axis=1)

df.to_csv("drive/MyDrive/Dataset/DataProcess/SynCleanBgt1.csv")

df.head()

df.describe()

pip install scikit-learn

from sklearn.feature_selection import chi2
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


df_data = pd.read_csv("drive/MyDrive/Dataset/DataProcess/SynCleanBgt1.csv")
df_data = df_data[[' Source Port', ' Destination IP',' Destination Port','Label']]

class Tree:
	def __init__(self,observationIDs,features,currLvl=0,subTree={},bestFeature=None,majorityLabel=None,parentMajorityLabel=None):
		self.observationIDs = observationIDs
		self.features = features
		self.currLvl = currLvl
		self.subTree = subTree
		self.bestFeature = bestFeature
		self.majorityLabel = majorityLabel
		self.parentMajorityLabel = parentMajorityLabel
		self.setBestFeatureID(bestFeature)

def setBestFeatureID(self, feature):
		idx = None
		if feature == ' Source Port':
			idx = 0
		elif feature == ' Destination IP':
			idx = 1
		else:
			idx = 2
		self.bestFeatureID = int(idx)

def predict(tree, obs):
    if tree.bestFeature == None:
      return tree.majorityLabel
    featVal = obs[tree.bestFeatureID]
    if not featVal in tree.subTree: # val with no subtree
      return tree.majorityLabel
    else: # recurse on subtree
      return predict(tree.subTree[featVal],obs)

def displayDecisionTree(tree):
    print('\t'*tree.currLvl + '(lvl {}) {}'.format(tree.currLvl,tree.majorityLabel))
    if tree.bestFeature == None:
      return

    print('\t'*tree.currLvl + '{}'.format(tree.bestFeature) + ': ')
    for [val,subTree] in sorted(tree.subTree.items()):
      print('\t'*(tree.currLvl+1) + 'choice: {}'.format(val))
      displayDecisionTree(subTree)

def Entropy(ns):
    entropy = 0.0
    total = sum(ns)
    for x in ns:
      entropy += -1.0*x/total*math.log(1.0*x/total,2)
    return entropy

def IG(observationIDs, feature):
	
	df = df_data.loc[observationIDs]

	labelCountDict = {}
	valueLabelCountDict = {}
	for index, row in df.iterrows():
		label = row['Label']
		if not label in labelCountDict:
			labelCountDict[label] = 0 
		labelCountDict[label] += 1
		featureValue = row[feature]
		if not featureValue in valueLabelCountDict:
			valueLabelCountDict[featureValue] = {} 
		if not label in valueLabelCountDict[featureValue]:
			valueLabelCountDict[featureValue][label] = 0 
		valueLabelCountDict[featureValue][label] += 1

	ns = []
	for [label,count] in labelCountDict.items():
		ns.append(count)

	H_Y = Entropy(ns)

	H_Y_X = 0.0
	for [featureValue, labelCountDict] in valueLabelCountDict.items():
		nsHYX = []
		for [label,count] in labelCountDict.items():
			nsHYX.append(count)
		H_Y_X += 1.0*sum(nsHYX)/len(df)*Entropy(nsHYX)
	return H_Y - H_Y_X

def GR(observationIDs, feature):
	ig = IG(observationIDs,feature)
	if ig == 0:
		return 0
	df = df_data.loc[observationIDs]
	valueLabelDict = {}
	for index, row in df.iterrows():
		label = row['Label']
		featureValue = row[feature]
		if featureValue not in valueLabelDict:
			valueLabelDict[featureValue] = 0
		valueLabelDict[featureValue] += 1
	ns = []
	for [val,count] in valueLabelDict.items():
		ns.append(count)
	ent = Entropy(ns)
	return float(ig)/ent

def fillDecisionTree(tree,decisionTreeAlgo):

	df = df_data.loc[tree.observationIDs] 
	counts = df['Label'].value_counts()
	majorityLabel = df['Label'].value_counts().idxmax()
	if len(counts) > 1:
		if counts['Win'] == counts['Lose']:
			majorityLabel = tree.parentMajorityLabel
	tree.majorityLabel = majorityLabel


	if len(counts) == 1:
		return
	
	if len(tree.features) == 0: 
		return


	featureValueDict = {}
	for feature in tree.features: 
		if decisionTreeAlgo == 'ID3':
			metricScore = IG(tree.observationIDs,feature)
		if decisionTreeAlgo == 'C45':
			metricScore = GR(tree.observationIDs,feature)
		featureValueDict[feature] = metricScore
	bestFeature, bestFeatureValue = sorted(featureValueDict.items(),reverse=True)[0]

	if bestFeatureValue == 0.0:
		return
	tree.bestFeature = bestFeature

	
	subFeatures = set()
	for feature in tree.features:
		if feature == bestFeature: 
			continue
		subFeatures.add(feature)
  

	bestFeatureIdx = 0
	if bestFeature == ' Source Port':
		bestFeatureIdx = 0
	elif bestFeature == ' Destination IP':
		bestFeatureIdx = 1
	else:
		bestFeatureIdx = 2
	
	subObservationsDict = {}
	for obs in tree.observationIDs:
		val = df_data.values[obs][bestFeatureIdx]
		if not val in subObservationsDict:
			subObservationsDict[val] = set()
		subObservationsDict[val].add(obs)

	for [val,obs] in subObservationsDict.items():

		tree.subTree[val] = Tree(obs, subFeatures, tree.currLvl + 1,{},None,None,majorityLabel)
		
		fillDecisionTree(tree.subTree[val],decisionTreeAlgo)

df.to_csv("drive/MyDrive/Dataset/DataProcess/SynDataProcessingWithChiSquare1.csv")